"""
OpenRouter OAuth2 PKCE Service

Handles OAuth2 PKCE flow for OpenRouter API key enrollment.
All OAuth operations are proxied through the backend to protect credentials.
"""

import httpx
import uuid
from datetime import datetime
from typing import Optional, Dict, Any
from cryptography.fernet import Fernet
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from app.models.models import OpenRouterKey, Session as DBSession
from app.core.config import settings


class OpenRouterOAuthService:
    """Service for managing OpenRouter OAuth2 PKCE flow"""
    
    OPENROUTER_AUTH_URL = "https://openrouter.ai/auth"
    OPENROUTER_TOKEN_URL = "https://openrouter.ai/api/v1/auth/keys"
    OPENROUTER_API_URL = "https://openrouter.ai/api/v1"
    
    def __init__(self, db: AsyncSession):
        self.db = db
        # Initialize encryption key (in production, load from secure key management)
        # For now, derive from SESSION_SECRET_KEY
        self._init_encryption()
    
    def _init_encryption(self):
        """Initialize Fernet encryption using session secret"""
        # Derive a 32-byte key from SESSION_SECRET_KEY
        import hashlib
        key_material = settings.SESSION_SECRET_KEY.encode()
        derived_key = hashlib.sha256(key_material).digest()
        # Fernet requires base64-encoded 32-byte key
        import base64
        fernet_key = base64.urlsafe_b64encode(derived_key)
        self.cipher = Fernet(fernet_key)
    
    def _encrypt_key(self, api_key: str) -> str:
        """Encrypt an API key for storage"""
        return self.cipher.encrypt(api_key.encode()).decode()
    
    def _decrypt_key(self, encrypted_key: str) -> str:
        """Decrypt an API key from storage"""
        return self.cipher.decrypt(encrypted_key.encode()).decode()
    
    def generate_oauth_url(
        self, 
        code_challenge: str,
        code_challenge_method: str = "S256",
        callback_url: str = None
    ) -> str:
        """
        Generate OpenRouter OAuth2 authorization URL
        
        Args:
            code_challenge: PKCE code challenge generated by frontend
            code_challenge_method: Challenge method (S256 or plain)
            callback_url: OAuth callback URL (auto-detected from request)
        
        Returns:
            Authorization URL to redirect user to
        """
        # Use provided callback URL (from request headers) or fall back to config
        if not callback_url:
            callback_url = settings.INSTANCE_URL.rstrip('/') + '/oauth/callback'
        
        params = {
            "callback_url": callback_url,
            "code_challenge": code_challenge,
            "code_challenge_method": code_challenge_method
        }
        
        # Build query string
        query_string = "&".join([f"{k}={v}" for k, v in params.items()])
        return f"{self.OPENROUTER_AUTH_URL}?{query_string}"
    
    async def exchange_code_for_key(
        self,
        session_id: str,
        code: str,
        code_verifier: str,
        code_challenge_method: str = "S256"
    ) -> Dict[str, Any]:
        """
        Exchange OAuth authorization code for OpenRouter API key
        
        This method proxies the token exchange through our backend,
        keeping the API key secure and never exposing it to the frontend.
        
        Args:
            session_id: Current user session ID
            code: Authorization code from OAuth callback
            code_verifier: PKCE code verifier (matching the challenge)
            code_challenge_method: Challenge method used
        
        Returns:
            Dict with status and key info (without exposing the actual key)
        """
        # Validate session exists
        result = await self.db.execute(
            select(DBSession).where(DBSession.id == session_id)
        )
        db_session = result.scalar_one_or_none()
        if not db_session:
            raise ValueError(f"Session {session_id} not found")
        
        # Exchange code for API key with OpenRouter
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    self.OPENROUTER_TOKEN_URL,
                    json={
                        "code": code,
                        "code_verifier": code_verifier,
                        "code_challenge_method": code_challenge_method
                    },
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                data = response.json()
                
                api_key = data.get("key")
                if not api_key:
                    raise ValueError("No API key returned from OpenRouter")
                
                # Get key label if available
                key_label = data.get("label", "OpenRouter API Key")
                
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 403:
                    raise ValueError("Invalid authorization code or code_verifier")
                elif e.response.status_code == 400:
                    raise ValueError("Invalid code_challenge_method")
                else:
                    raise ValueError(f"OpenRouter API error: {e.response.status_code}")
            except Exception as e:
                raise ValueError(f"Failed to exchange code: {str(e)}")
        
        # Encrypt and store the API key
        encrypted_key = self._encrypt_key(api_key)
        
        # Check if key already exists for this session
        result = await self.db.execute(
            select(OpenRouterKey).where(OpenRouterKey.session_id == session_id)
        )
        existing_key = result.scalar_one_or_none()
        
        if existing_key:
            # Update existing key
            existing_key.encrypted_api_key = encrypted_key
            existing_key.key_label = key_label
            existing_key.is_active = True
            existing_key.updated_at = datetime.utcnow()
        else:
            # Create new key record
            db_key = OpenRouterKey(
                id=str(uuid.uuid4()),
                session_id=session_id,
                encrypted_api_key=encrypted_key,
                key_label=key_label,
                is_active=True
            )
            self.db.add(db_key)
        
        await self.db.commit()
        
        # Fetch credits info (optional, for display)
        credits_info = await self._fetch_credits(api_key)
        
        return {
            "success": True,
            "key_label": key_label,
            "has_key": True,
            "credits_remaining": credits_info.get("credits_remaining"),
            "credits_total": credits_info.get("credits_total")
        }
    
    async def get_api_key(self, session_id: str) -> Optional[str]:
        """
        Retrieve decrypted API key for a session
        
        This method is used internally by the backend to make
        OpenRouter API calls on behalf of the user.
        
        Args:
            session_id: User session ID
        
        Returns:
            Decrypted API key or None if not found
        """
        result = await self.db.execute(
            select(OpenRouterKey).where(
                OpenRouterKey.session_id == session_id,
                OpenRouterKey.is_active == True
            )
        )
        db_key = result.scalar_one_or_none()
        
        if not db_key:
            return None
        
        # Update last_used_at
        db_key.last_used_at = datetime.utcnow()
        await self.db.commit()
        
        return self._decrypt_key(db_key.encrypted_api_key)
    
    async def get_key_status(self, session_id: str) -> Dict[str, Any]:
        """
        Get status of OpenRouter API key for a session
        
        Returns key info without exposing the actual key.
        
        Args:
            session_id: User session ID
        
        Returns:
            Dict with key status and info
        """
        result = await self.db.execute(
            select(OpenRouterKey).where(
                OpenRouterKey.session_id == session_id,
                OpenRouterKey.is_active == True
            )
        )
        db_key = result.scalar_one_or_none()
        
        if not db_key:
            return {
                "has_key": False,
                "connected": False
            }
        
        # Try to fetch fresh credits info
        api_key = self._decrypt_key(db_key.encrypted_api_key)
        credits_info = await self._fetch_credits(api_key)
        
        # Update cached credits
        if credits_info:
            db_key.credits_remaining = credits_info.get("credits_remaining")
            await self.db.commit()
        
        return {
            "has_key": True,
            "connected": True,
            "key_label": db_key.key_label,
            "credits_remaining": credits_info.get("credits_remaining"),
            "credits_total": credits_info.get("credits_total"),
            "created_at": db_key.created_at.isoformat(),
            "last_used_at": db_key.last_used_at.isoformat() if db_key.last_used_at else None
        }
    
    async def revoke_key(self, session_id: str) -> bool:
        """
        Revoke (deactivate) OpenRouter API key for a session
        
        Args:
            session_id: User session ID
        
        Returns:
            True if key was revoked, False if not found
        """
        result = await self.db.execute(
            update(OpenRouterKey)
            .where(OpenRouterKey.session_id == session_id)
            .values(is_active=False, updated_at=datetime.utcnow())
        )
        
        await self.db.commit()
        return result.rowcount > 0
    
    async def _fetch_credits(self, api_key: str) -> Dict[str, Any]:
        """
        Fetch credits information from OpenRouter API
        
        Args:
            api_key: OpenRouter API key
        
        Returns:
            Dict with credits info
        """
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.OPENROUTER_API_URL}/auth/key",
                    headers={
                        "Authorization": f"Bearer {api_key}",
                        "HTTP-Referer": settings.INSTANCE_URL,  # Use INSTANCE_URL for consistency
                        "X-Title": settings.OPENROUTER_APP_NAME
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                return {
                    "credits_remaining": data.get("data", {}).get("limit_remaining"),
                    "credits_total": data.get("data", {}).get("limit")
                }
        except Exception as e:
            print(f"Failed to fetch credits: {e}")
            return {}
